### Algorithm (알고리즘)

![](https://velog.velcdn.com/images/wonderheeman/post/8e262cc0-7bdc-498b-9097-7e6391ae7628/image.png)
#### _어떠한 문제를 해결하기 위한 일련의 절차를 공식화한 형태로 표현한 것_

프로그래밍에서 알고리즘은 input값을 통해 output값을 얻기 위한 계산 과정
문제를 해결할 때, 정확하고 효율적으로 결과값을 얻기 위해서 알고리즘이 필요하다.

<hr>

#### 알고리즘의 조건

- 입력 : 외부에서 제공되는 자료가 0개 이상 존재한다.
* 출력 : 적어도 2개 이상의 서로 다른 결과를 내어야 한다. (모든 입력에 하나의 출력이 나오면 안된다.)
* 명확성 : 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.
* 유한성 : 유한 번의 명령어를 수행 후 유한 시간 내에 종료한다.
* 효율성 : 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다.

<hr>

#### 좋은 알고리즘의 기준

* 정확성 : 적당한 입력에 대해서 유한 시간내에 올바른 답을 산출하는가를 판단.
* 작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정, 해결하고자 하는 문제의 중요 연산이 여러개인 경우에는 중요 연산들의 함으로 간주하거나 중요 연산들에 가중치를 두어 계산
* 기억 장소 사용량  : 수행에 필요한 저장 공간
* 최적성 : 그 알고리즘보다 더 적은 연산을 수행하는 알고리즘은 없는가? 최적이랑 가장 '잘 알려진' 이 아니라 '가장 좋은'의 의미이다.
* 복잡도 (점근 표기법 : Big-O Notation) : 알고리즘이 소모하는 소요 시간과 메모리 사용량 등의 자원이다. 전자를 시간 복잡도, 후자를 공간 복잡도라 한다.
![](https://velog.velcdn.com/images/wonderheeman/post/0ddc803c-75cb-4ac5-8d9f-8a9e1d2da3d6/image.png)

<hr>

#### 알고리즘의 분류 
#### - 정렬
**1. 버블정렬(Bubble)**
1-1. 인접한 두 데이터의 크기를 비교하여 정렬하는 알고리즘
![](https://velog.velcdn.com/images/wonderheeman/post/8447d119-7df6-4b0a-9e01-ecb26f2c058e/image.gif)
**2. 선택 정렬 (Selection)**
2-1.  주어진 데이터 중 최소값을 찾아 순서대로 정렬하는 알고리즘
2-2. 후보군 중 최소값을 찾아낸 후, 맨 앞의 데이터와 교체한다.
2-3. 교체된 맨 앞의 데이터를 제외한 나머지 후보군에서 다시 최소값을 찾아낸다.![](https://velog.velcdn.com/images/wonderheeman/post/99f390da-466b-413a-9dfc-327ce4e7ec29/image.gif)
**3. 삽입 정렬(Insertion)**
3-1. 1번 index에 위치한 데이터를 기준으로 해당 데이터의 앞 쪽에 위치한 데이터와 비교한다. 
3-2. 더 작은 값을 찾을때까지 데이터를 뒤로 밀어내어 정렬하는 알고리즘
3-3. 삽입된 데이터보다 작은 데이터를 만날 때까지 반복한다. 없는 경우, 0번 index에 위치하게 된다.![](https://velog.velcdn.com/images/wonderheeman/post/faf74df9-d0b3-4396-87c5-32f9538ea191/image.gif)
**4. 퀵 정렬(Quick)**
4-1. 데이터에서 기준점(pivot)을 정하여 pivot보다 작다면 좌측(left)에, 크다면 우측(right)에 정렬한다.
4-2. 좌/우측으로 1차 정렬된 데이터에서 좌/우측 각각의 pivot을 다시 선정하고 정렬을 수행한다.
4-3. 이 과정을 재귀함수를 사용하여 반복하며, 최종적으로 정렬된 데이터를 반환한다.
![](https://velog.velcdn.com/images/wonderheeman/post/5e2ddbec-37d1-44a5-8e6b-de7e788fba65/image.png)
**5. 병합정렬**
5-1. 분할 정복 알고리즘을 기반한 정렬이며, 재귀함수를 사용한다.
5-2. 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
5-3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
5-4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

#### - 탐색(Search)
**1. 이진 탐색(Binary Search)**
1-1. 탐색할 자료를 반으로 나누어 찾는 데이터가 있을만한 곳을 탐색하는 방법

**2. 순차 탐색**
2-1. 데이터가 담겨있는 리스트를 앞에서부터 하나씩 순차적으로 비료하여 원하는 데이터를 찾는 방법
![](https://velog.velcdn.com/images/wonderheeman/post/43ec422f-c0e1-4e70-8456-e33ad21ded3a/image.gif)
#### 그래프(Graph)
1. 너비우선탐색(BFS)
1-1. 정점(노드)과 같은 레벨에 있는 노드(=형제노드)를 먼저 탐색하는 방식
![](https://velog.velcdn.com/images/wonderheeman/post/3132eb32-1fc2-4219-946b-bb323f41ce5e/image.png)
2. 깊이 우선 탐색(DFS)
2-1. 정점(노드)의 자식노드를 먼저 탐색하는 방식
![](https://velog.velcdn.com/images/wonderheeman/post/01c5633b-3e99-425e-9b6e-21e3f5731b00/image.png)

3. 최단경로 알고리즘(Shortest Path Algorithm)
3-1. 그래프에서 두 노드를 잇는 가장 짧은 경로를 찾는 알고리즘이다.
3-2. 간선(edge)의 가중치 합이 최소인 경로를 찾는 것이 목적이다.
3-3. 최단경로 알고리즘에는 3가지 문제유형이 있다.

