## **TCP/IP**

![1](https://github.com/user-attachments/assets/1b4c7360-55df-46bd-b388-3135244815ea)

#### **인터넷 프로토콜 스위트(Internet Protocol Suite)**

-   인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 프로토콜(통신규약)의 모음
-   TCP와 IP가 가장 많이 쓰이므로 TCP/IP 프로토콜 스위트라고도 부른다.
-   패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다.
-   IP는 패킷 전달 여부를 보증하지 않고 패킷을 보내고 받는 순서가 다를 수 있고  
    TCP는 IP 위에서 동작하는 프로토콜로 데이터의 전달을 보증하며 보낸 순서대로 받는다.
-   IP 주소 체계를 따르고 IP Routing을 이용해 목적지에 도달하며  
    TCP 특성을 활용해 송/수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 한다.  
    즉, 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고 이 데이터가 제대로 갔는지, 너무 빠르지는 않은지, 제대로 받았다고 응답이 오는지에 대한 이야기를 한다.

#### **OSI 7 Layer**

-   네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것

**Transport Layer(4 Layer)**

-   송신자와 수신자의 논리적 연결을 담당하는 부분
-   신뢰성 있는 연결을 유지할 수 있도록 도움을 주는 역할
-   Endpoint(사용자) 간의 연결을 생성하고 데이터를 얼마나 보내고, 제대로 받았는지 등을 확인한다.
-   HTTP, HTTPS, FTP, SMTP 등 데이터를 안정적으로 보내는 것을 중요시하는 프로토콜들의 기반이 되며  
    TCP의 "3-way handshake"를 거친 후 각자 프로토콜에 기반한 교환 과정을 실시한다.
-   Ex) TCP, UDP

**Network Layer(3 Layer)**

-   IP(Internet Protocol)가 활용되는 부분
-   한 Endpoint가 다른 Endpoint로 가고자 할 경우 경로와 목적지를 찾아주는 Routing 역할

**TCP(Transmission Control Protocal, 전송 제어 프로토콜)**

-   근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
-   전송 계층에 위치하여 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜 중 하나이다.
-   웹 브라우저들이 월드 와이드 웹(WWW)에서 서버에 연결할 때 사용되며 이메일 및 파일 전송 시에도 사용된다.

▶ **TCP Header**

![2](https://github.com/user-attachments/assets/7fdc8f2c-aa3d-4a4c-9385-ceaafafc4057)

-   IP가 패킷들의 관계를 이해하지 않고 목적지를 찾아가는 것에 중점을 둔다면  
    TCP는 통신하고자 하는 양쪽의 Endpoint가 통신할 준비가 됐는지, 데이터가 제대로 전송됐는지, 데이터가 손상되지 않았는지, 데이터가 빠진 부분이 없는지 등을 점검한다.
-   이러한 정보가 TCP Header에 담겨있으며 신뢰성 보장과 흐름 제어, 혼잡 제어에 관여할 수 있는 요소를 포함한다.
-   TCP가 실을 수 있는 데이터 크기를 "세그먼트(Segment)" 라고 부른다.
-   여러 필드로 나누어진 20 bytes, 즉 160 bits의 헤더를 사용하며 각 필드의 비트를 0 또는 1로 변경하여 전송하고자 하는 세그먼트의 정보를 나타낸다.
-   여러 옵션들을 사용하면 옵션 필드들이 추가로 붙으므로 60 bytes까지도 사용할 수 있다.

-   **Source port / Destination port**  
    \- 세그먼트의 출발지와 목적지를 나타내는 필드  
    \- 각각 16 bits를 할당받는다.  
    \- 출발지와 목적지의 주소를 판별하기 위해 IP 주소와 Port 번호를 필요로 한다.
-   **Sequence Number**  
    \- 전송하는 데이터의 순서를 나타내는 필드  
    \- 32 bits를 할당받는다.  
    \- 수신자는 나누어져 보내진 세그먼트의 순서를 파악하여 데이터를 재조립할 수 있다.  
    \- 송신자가 데이터를 전송할 때 번호를 랜덤 수로 초기화하며 데이터 1 bytes 당 1씩 증가시켜 순서를 표현한다.
-   **Acknowledgment Number**  
    \- 수신자가 예상하는 데이터의 다음 시퀀스 번호를 나타내는 필드  
    \- 32 bits를 할당받는다.  
    \- 송신자가 보낸 시퀀스 번호 + 수신자가 받은 데이터의 bytes로 승인 번호를 만들어낸다.
-   **Data Offset**  
    \- 전체 세그먼트 중 헤더가 아닌 데이터가 시작되는 위치가 어디부터인지를 나타내는 필드  
    \- 표기 시 32bit Word 단위를 사용하며 1 Word = 4 bytes 이므로 이 필드 값에 4를 곱하면 세그먼트에서 헤더를 제외한 실제 데이터의 시작 위치를 알 수 있다.  
    \- 옵션 필드의 길이가 고정되어 있지 않으므로 필요한 필드이다.
-   **Reserved**  
    \- 미래를 위해 예약된 필드로 0으로 채운다.  
    \- 3 bits를 할당받는다.
-   **Flags**  
    \- 현재 세그먼트의 속성을 나타내는 필드  
    \[URG\]  
        Urgent Pointer(긴급 포인터) 필드에 값이 있음을 알리는 플래그  
        이 포인터가 가리키는 긴급 데이터가 먼저 처리된다.  
    \[ACK\]  
        Acknowledgment(승인 번호) 필드에 값이 있음을 알리는 플래그  
        0일 경우 승인 번호 필드 자체가 무시된다.  
    \[PSH\]  
        수신 측에 데이터를 최대한 빠르게 응용 프로그램에 전달해달라고 요청하는 플래그  
    \[RST\]  
        이미 연결이 확립되어 ESTABLISHED 상태인 상대에게 연결을 강제로 리셋해달라고 요청하는 플래그  
    \[SYN\]  
        상대와 연결을 생성할 때 시퀀스 번호의 동기화를 맞추기 위한 세그먼트임을 알리는 플래그  
    \[FIN\]  
        상대방과 연결을 종료하고 싶다고 요청하는 세그먼트임을 알리는 플래그  
    ▷ 명시적 혼잡통보(Explicit Congestion Notification, ECN)을 위해 Reserved 필드를 사용하여 추가된 3개의 플래그  
    \[NS\]  
        ECN에서 사용하는 CWR, ECE 필드가 실수나 악의적으로 은폐되는 경우를 막기 위해 RFC 3540에서 추가된 필드  
    \[ECE\]  
        해당 필드가 1이면서 SYN 플래그가 1인 경우에는 상대에게 ECN 사용을 알리는 플래그  
        해당 필드가 1이면서 SYN 플래그가 0인 경우에는 상대에게 네트워크가 혼잡하니  
        세그먼트 위도우 크기를 줄여달라고 요청하는 플래그   
    \[CWR\]  
        이미 ECE 플래그를 받아 전송하는 세그먼트 윈도우 크기를 줄였다고 알리는 플래그
-   **Window Size**  
    \- 한번에 전송할 수 있는 데이터의 양을 의미하는 값을 담는 필드
-   **Checksum**  
    \- 데이터 송신 중 발생할 수 있는 오류를 검출하기 위한 값을 담는 필드
-   **Urgent Pointer**
-   **Options**  
    \- TCP 기능을 확잘할 때 사용하는 필드들  
    \- 크기가 고정되지 않고 가변적이므로 Data Offset 필드를 사용한다.

▶ **3-way handshake**

[##_Image|kage@bq8T4I/btsICl06q1O/YYe4eENhmRl4M5HSuSzVGk/img.jpg|CDM|1.3|{"originWidth":550,"originHeight":353,"style":"alignCenter"}_##]

-   TCP를 사용하는 송/수신자는 데이터 전송 전 서로 통신이 가능한지 의사를 묻고 한 번에 얼마나 받을 수 있는지 등의 정보를 확인하여 신뢰성 있는 통신을 한다.
-   TCP로 이루어지는 모든 통신은 반드시 이 과정을 거친다.
-   동작 과정  
    1. 송신자가 수신자에게 "SYN"을 보내 통신이 가능한지 확인한다. 이 때, Port가 열려 있어야 한다.  
    2. 수신자가 송신자로부터 "SYN"을 받고 "SYN/ACK"를 송신자에게 보내 통신 준비가 되었음을 알린다.  
    3. 송신자가 수신자의 "SYN/ACK"를 받고 "ACK"를 보내 전송 시작을 알린다.

▶ **특징**

-   **흐름 제어**  
    \- 송신자는 자신이 데이터를 한 번에 얼마나 보낼 수 있는지, 수신자는 자신이 데이터를 어디까지 받았는지 끊임없이 확인한다.  
    \- 수신자가 한번에 받고/보낼 수 있는 데이터의 양을 Window size로 정하고 수시로 조절한다.  
    \- 수신자가 자신이 받은 데이터의 양을 확인하여 Acknowledgment Number로 보내면 송신자가 보낼 데이터의 순서가 Sequence Number로 표기된다. 
-   **혼잡 제어**  
                                                                                                      \- 데이터가 지나가는 네트워크망의 혼잡 제어도 중요하다.  
                                                                                                      \- 연결 초기 송신자가 데이터 송출량을 낮게 잡고 보내면서 수신 상태를 확인하고 송출량을 조금씩 늘려간다  
      이를 통해 현재 네트워크에서 가장 적합한 데이터 송출량을 알 수 있게 되는데 이를 "Slow Start"라고 한다.

▷ 출처

[https://aws-hyoh.tistory.com/57](https://aws-hyoh.tistory.com/57)

[https://evan-moon.github.io/2019/11/10/header-of-tcp/](https://evan-moon.github.io/2019/11/10/header-of-tcp/)

[https://velog.io/@juijeong8324/Network-2](https://velog.io/@juijeong8324/Network-2)

[https://www.mdpi.com/2076-3417/6/11/358](https://www.mdpi.com/2076-3417/6/11/358)